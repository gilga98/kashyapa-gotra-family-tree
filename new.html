<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Family Tree (Vanilla JS)</title>
    
    <!-- CDN Libraries (No D3) -->
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>
    <script src="https://unpkg.com/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
    
    <style>
        /* Styles remain exactly the same as before */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, system-ui, sans-serif; background: #f5f7fa; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        
        #controls { background: white; padding: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); z-index: 100; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
        #search-input { flex: 1; min-width: 200px; padding: 10px 14px; border: 2px solid #e1e8ed; border-radius: 8px; font-size: 14px; }
        .filter-group { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .filter-btn { padding: 8px 16px; border: 2px solid #e1e8ed; background: white; border-radius: 20px; cursor: pointer; min-height: 44px; }
        .filter-btn:hover { background: #e8f5fe; border-color: #1da1f2; }
        .filter-btn.active { background: #1da1f2; color: white; border-color: #1da1f2; }
        .reset-btn { padding: 8px 16px; background: #657786; color: white; border: none; border-radius: 20px; cursor: pointer; min-height: 44px; }
        
        #tree-container { flex: 1; position: relative; overflow: hidden; background: #f5f7fa; }
        #tree-svg { width: 100%; height: 100%; cursor: grab; }
        #tree-svg:active { cursor: grabbing; }

        /* Node Styles */
        .person-node { cursor: pointer; transition: transform 0.2s; }
        .person-node:hover { transform: scale(1.05); }
        .person-card { fill: white; stroke: #e1e8ed; stroke-width: 2; rx: 8; ry: 8; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1)); }
        
        .person-card.male { stroke: #4A90E2; }
        .person-card.female { stroke: #E94B8B; }
        .person-card.highlighted { stroke: #FFD700; stroke-width: 4; filter: drop-shadow(0 4px 12px rgba(255,215,0,0.5)); }
        .person-card.collapsed { opacity: 0.7; }
        
        .person-name { font-size: 14px; font-weight: 600; fill: #14171a; pointer-events: none; }
        .person-dates { font-size: 11px; fill: #657786; pointer-events: none; }
        .person-icon { font-size: 16px; pointer-events: none; }
        
        /* Links */
        .link { fill: none; stroke: #AAB8C2; stroke-width: 2; }
        .spouse-link { stroke: #E94B8B; stroke-width: 2; stroke-dasharray: 5,5; }
        
        /* UI Elements */
        #info-panel { position: absolute; top: 20px; right: 20px; background: white; padding: 16px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); max-width: 300px; display: none; z-index: 50; }
        #info-panel.visible { display: block; }
        .close-info { position: absolute; top: 8px; right: 8px; border: none; background: none; font-size: 20px; cursor: pointer; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #657786; text-align: center; }
        
        .zoom-controls { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 8px; }
        .zoom-btn { width: 44px; height: 44px; background: white; border: 2px solid #e1e8ed; border-radius: 50%; cursor: pointer; font-size: 20px; }
    </style>
</head>
<body>
    <div id="controls">
        <input type="text" id="search-input" placeholder="üîç Search by name..." />
        <div class="filter-group">
            <button class="filter-btn" data-filter="gender" data-value="male">üë® Male</button>
            <button class="filter-btn" data-filter="gender" data-value="female">üë© Female</button>
            <button class="filter-btn" data-filter="status" data-value="alive">üíö Alive</button>
            <button class="filter-btn" data-filter="status" data-value="deceased">üïäÔ∏è Deceased</button>
            <button class="reset-btn" id="reset-filters">Reset</button>
        </div>
    </div>

    <div id="tree-container">
        <div id="loading">Loading...</div>
        <svg id="tree-svg"></svg>
        
        <div id="info-panel">
            <button class="close-info" onclick="closeInfo()">√ó</button>
            <div id="info-content"></div>
        </div>

        <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomIn()">+</button>
            <button class="zoom-btn" onclick="zoomReset()">‚äô</button>
            <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
        </div>
    </div>

    <script>
        // ============================================
        // 1. DATA MANAGEMENT (Pure JS - Unchanged)
        // ============================================
class FamilyTreeData {
            constructor(jsonData) {
                this.rawData = jsonData;
                this.peopleMap = new Map();
                this.roots = [];
                this.collapsed = new Set();
                this.initialize();
            }
            initialize() {
                this.rawData.people.forEach(person => {
                    this.peopleMap.set(person.id, { ...person, parents: person.parents||[], spouses: person.spouses||[], children: person.children||[] });
                });
                this.normalizeRelationships();
                this.detectRoots();
            }
            normalizeRelationships() {
                this.peopleMap.forEach((person, id) => {
                    person.spouses.forEach(sId => { const s = this.peopleMap.get(sId); if (s && !s.spouses.includes(id)) s.spouses.push(id); });
                    person.children.forEach(cId => { const c = this.peopleMap.get(cId); if (c && !c.parents.includes(id)) c.parents.push(id); });
                    person.parents.forEach(pId => { const p = this.peopleMap.get(pId); if (p && !p.children.includes(id)) p.children.push(id); });
                });
            }
            detectRoots() {
                const potential = [];
                this.peopleMap.forEach((p, id) => { if (p.parents.length === 0) potential.push(id); });
                const processed = new Set();
                const groups = [];
                potential.forEach(pid => {
                    if (processed.has(pid)) return;
                    const p = this.peopleMap.get(pid);
                    const g = [pid]; processed.add(pid);
                    p.spouses.forEach(sid => {
                        const s = this.peopleMap.get(sid);
                        if (!s || s.parents.length > 0) return;
                        if (!processed.has(sid)) { g.push(sid); processed.add(sid); }
                    });
                    if (g.length) groups.push(g);
                });
                this.roots = groups.map(g => g[0]);
                if (!this.roots.length && this.peopleMap.size > 0) this.roots = [this.peopleMap.keys().next().value];
            }
            getPerson(id) { return this.peopleMap.get(id); }
            toggleCollapse(id) { this.collapsed.has(id) ? this.collapsed.delete(id) : this.collapsed.add(id); }
            isCollapsed(id) { return this.collapsed.has(id); }
            getAllAncestors(id, v=new Set()) { if(v.has(id))return[]; v.add(id); const p=this.getPerson(id); return p?p.parents.flatMap(pid=>[pid,...this.getAllAncestors(pid,v)]):[]; }
            getAllDescendants(id, v=new Set()) { if(v.has(id))return[]; v.add(id); const p=this.getPerson(id); return p?p.children.flatMap(cid=>[cid,...this.getAllDescendants(cid,v)]):[]; }
        }


        // ============================================
        // 2. LAYOUT ENGINE (Pure JS - Unchanged)
        // ============================================
        class TreeLayout {
    constructor(data) { this.data = data; this.nodeW=180; this.nodeH=80; this.gapH=40; this.gapV=100; this.spouseGap=20; }
    buildHierarchy(rid, depth=0, v=new Set()) {
        if(v.has(rid)) return null; v.add(rid);
        const p = this.data.getPerson(rid); if(!p) return null;
        const node = { id: rid, data: p, depth, children:[], spouses:[], x:0, y: depth*(this.nodeH+this.gapV) };
        p.spouses.forEach(sid => { const s = this.data.getPerson(sid); if(s) node.spouses.push({id:sid, data:s, x:0, y:node.y}); });
        if(!this.data.isCollapsed(rid)) p.children.forEach(cid => { const c=this.buildHierarchy(cid, depth+1, v); if(c) node.children.push(c); });
        return node;
    }
    calculatePositions(node, x=0) {
        if(!node) return 0;
        let childW=0, childX=x;
        node.children.forEach((c,i) => { const w=this.calculatePositions(c, childX); childX+=w+this.gapH; childW+=w+(i>0?this.gapH:0); });
        const selfW = this.nodeW + (node.spouses.length*(this.nodeW+this.spouseGap));
        const totalW = Math.max(selfW, childW);
        node.x = node.children.length>0 ? (x + childW/2 - selfW/2) : x;
        node.spouses.forEach((s,i) => s.x = node.x + (i+1)*(this.nodeW+this.spouseGap));
        return totalW;
    }
    layoutMultipleRoots(roots) {
        const trees=[]; let offX=0;
        roots.forEach(rid => {
            const t = this.buildHierarchy(rid);
            if(t) { this.calculatePositions(t); this.shiftTree(t, offX); trees.push(t); offX+=this.getTreeWidth(t)+100; }
        });
        return trees;
    }
    shiftTree(n, dx) { n.x+=dx; n.spouses.forEach(s=>s.x+=dx); n.children.forEach(c=>this.shiftTree(c,dx)); }
    getTreeWidth(n) { let mx=n.x+this.nodeW; n.spouses.forEach(s=>mx=Math.max(mx,s.x+this.nodeW)); n.children.forEach(c=>mx=Math.max(mx,this.getTreeWidth(c))); return mx; }
}

        // ============================================
        // 3. RENDERER (REWRITTEN: Vanilla JS SVG)
        // ============================================
        class TreeRenderer {
    constructor(svgElement, familyData) {
        this.svg = svgElement;
        this.data = familyData;
        this.layout = new TreeLayout(familyData);
        this.ns = "http://www.w3.org/2000/svg";
        
        this.highlighted = new Set();
        this.filters = { gender: null, status: null };

        // Create a container Group <g> for Panzoom to transform
        this.mainGroup = document.createElementNS(this.ns, 'g');
        this.mainGroup.setAttribute('id', 'panzoom-viewport');
        
        this.linkGroup = document.createElementNS(this.ns, 'g');
        this.nodeGroup = document.createElementNS(this.ns, 'g');
        
        this.mainGroup.appendChild(this.linkGroup);
        this.mainGroup.appendChild(this.nodeGroup);
        this.svg.appendChild(this.mainGroup);
    }

    // Moved initialization outside constructor to ensure DOM is ready
    initPanzoom() {
        // Destroy previous instance if exists to prevent duplicates
        if (this.pz) this.pz.destroy();

        this.pz = Panzoom(this.mainGroup, {
            maxScale: 4,
            minScale: 0.1,
            contain: 'outside',
            cursor: 'grab'
        });

        // Attach wheel listener to SVG, not the group
        this.svg.addEventListener('wheel', (e) => {
            e.preventDefault(); // Prevent page scroll
            this.pz.zoomWithWheel(e);
        });
    }

    render() {
        const trees = this.layout.layoutMultipleRoots(this.data.roots);
        
        // Clear groups safely
        while(this.linkGroup.firstChild) this.linkGroup.removeChild(this.linkGroup.firstChild);
        while(this.nodeGroup.firstChild) this.nodeGroup.removeChild(this.nodeGroup.firstChild);

        const renderList = { nodes: [], links: [] };
        trees.forEach(tree => this.traverse(tree, renderList));

        this.drawLinks(renderList.links);
        this.drawNodes(renderList.nodes);
        
        // Initialize Panzoom ONLY on first render
        if (!this.pz) {
            this.initPanzoom();
            setTimeout(() => this.centerView(), 50);
        }
    }

    traverse(node, list) {
        if (this.isFiltered(node.data)) {
            list.nodes.push(node);
            node.spouses.forEach(s => {
                if (this.isFiltered(s.data)) {
                    list.nodes.push(s);
                    list.links.push({ type: 'spouse', source: node, target: s });
                }
            });
            node.children.forEach(child => {
                list.links.push({ type: 'child', source: node, target: child });
                this.traverse(child, list);
            });
        }
    }

    isFiltered(p) {
        if (this.filters.gender && p.gender !== this.filters.gender) return false;
        if (this.filters.status === 'alive' && p.deathDate) return false;
        if (this.filters.status === 'deceased' && !p.deathDate) return false;
        return true;
    }

    drawLinks(links) {
        const frag = document.createDocumentFragment();
        links.forEach(l => {
            if (l.type === 'spouse') {
                const line = document.createElementNS(this.ns, 'line');
                this.setAttrs(line, {
                    x1: l.source.x + 180, y1: l.source.y + 40,
                    x2: l.target.x, y2: l.target.y + 40,
                    class: 'spouse-link'
                });
                frag.appendChild(line);
            } else {
                const p = document.createElementNS(this.ns, 'path');
                const sx=l.source.x+90, sy=l.source.y+80, tx=l.target.x+90, ty=l.target.y;
                const d = `M ${sx},${sy} V ${sy+50} H ${tx} V ${ty}`;
                this.setAttrs(p, { d, class: 'link' });
                frag.appendChild(p);
            }
        });
        this.linkGroup.appendChild(frag);
    }

    drawNodes(nodes) {
        const frag = document.createDocumentFragment();
        nodes.forEach(n => {
            const g = document.createElementNS(this.ns, 'g');
            this.setAttrs(g, { class: 'person-node', transform: `translate(${n.x},${n.y})` });
            
            // Interaction: Use mouseup/touchend logic to distinguish click vs drag
            let startX, startY;
            g.addEventListener('mousedown', e => { startX=e.clientX; startY=e.clientY; });
            g.addEventListener('mouseup', e => {
                if(Math.abs(e.clientX-startX)<5 && Math.abs(e.clientY-startY)<5) {
                    e.stopPropagation(); this.handleNodeClick(n);
                }
            });
            // Touch support for interaction
            g.addEventListener('touchstart', e => { startX=e.touches[0].clientX; startY=e.touches[0].clientY; });
            g.addEventListener('touchend', e => {
                const endX=e.changedTouches[0].clientX, endY=e.changedTouches[0].clientY;
                if(Math.abs(endX-startX)<10 && Math.abs(endY-startY)<10) {
                    e.stopPropagation(); this.handleNodeClick(n);
                }
            });

            let cls = `person-card ${n.data.gender}`;
            if(this.highlighted.has(n.id)) cls += ' highlighted';
            if(this.data.isCollapsed(n.id)) cls += ' collapsed';

            const rect = document.createElementNS(this.ns, 'rect');
            this.setAttrs(rect, { width: 180, height: 80, class: cls });
            g.appendChild(rect);

            const txt = document.createElementNS(this.ns, 'text');
            txt.textContent = n.data.name;
            this.setAttrs(txt, { x: 35, y: 25, class: 'person-name' });
            g.appendChild(txt);
            
            const icon = document.createElementNS(this.ns, 'text');
            icon.textContent = n.data.gender==='male'?'üë®':(n.data.gender==='female'?'üë©':'üë§');
            this.setAttrs(icon, { x: 10, y: 25, class: 'person-icon' });
            g.appendChild(icon);

            const date = document.createElementNS(this.ns, 'text');
            date.textContent = `${n.data.birthDate||'?'} - ${n.data.deathDate||''}`;
            this.setAttrs(date, { x: 10, y: 45, class: 'person-dates' });
            g.appendChild(date);

            if(n.data.children.length) {
                const btn = document.createElementNS(this.ns, 'g');
                btn.setAttribute('transform', 'translate(155, 55)');
                btn.innerHTML = `<circle r="10" class="collapse-indicator"/><text text-anchor="middle" dy="4" fill="white" font-size="14" pointer-events="none">${this.data.isCollapsed(n.id)?'+':'‚àí'}</text>`;
                btn.style.cursor = "pointer";
                
                // Stop propagation on collapse button to prevent node click
                const stopProp = (e) => { e.stopPropagation(); this.data.toggleCollapse(n.id); this.render(); };
                btn.addEventListener('mousedown', stopProp);
                btn.addEventListener('touchstart', stopProp);
                
                g.appendChild(btn);
            }
            frag.appendChild(g);
        });
        this.nodeGroup.appendChild(frag);
    }

    setAttrs(el, attrs) { Object.entries(attrs).forEach(([k,v]) => el.setAttribute(k,v)); }
    
    handleNodeClick(node) {
        this.highlighted.clear();
        this.highlighted.add(node.id);
        this.data.getAllAncestors(node.id).forEach(id => this.highlighted.add(id));
        this.data.getAllDescendants(node.id).forEach(id => this.highlighted.add(id));
        node.data.spouses.forEach(id => this.highlighted.add(id));
        this.render();
        
        const p = document.getElementById('info-panel');
        p.innerHTML = `<button class="close-info" onclick="closeInfo()">√ó</button>
                       <h3>${node.data.name}</h3><p>${node.data.notes||''}</p>`;
        p.classList.add('visible');
    }

    centerView() {
        const bbox = this.mainGroup.getBBox();
        const parent = this.svg.getBoundingClientRect();
        if(bbox.width===0) return;
        const scale = Math.min(parent.width/(bbox.width+100), parent.height/(bbox.height+100), 1);
        const x = (parent.width - bbox.width*scale)/2 - bbox.x*scale;
        this.pz.pan(x, 50);
        this.pz.zoom(scale);
    }
    
    applyFilters(f) { this.filters=f; this.render(); }
    focusNode(id) {
        this.data.getAllAncestors(id).forEach(aid=>this.data.isCollapsed(aid)&&this.data.toggleCollapse(aid));
        this.highlighted.clear(); this.highlighted.add(id);
        this.render();
        setTimeout(() => {
            // Pan to node logic
            const n = this.data.getPerson(id);
            // We need to find the node's position from the layout cache (not stored here cleanly, re-find in DOM)
            // Simplified centering: Just re-center whole view for now or would need complex coordinate math
            this.centerView(); 
        }, 50);
    }
    clearHighlights() { this.highlighted.clear(); this.render(); }
}

        // ============================================
        // 4. APP INITIALIZATION
        // ============================================
        async function init() {
    try {
        const response = await fetch('./family-tree.json');
        if(!response.ok) throw new Error("Load failed");
        const jsonData = await response.json();
        
        const data = new FamilyTreeData(jsonData);
        const renderer = new TreeRenderer(document.getElementById('tree-svg'), data);
        
        // Search
        const fuse = new Fuse(jsonData.people, { keys:['name'], threshold:0.4 });
        document.getElementById('search-input').addEventListener('input', e => {
            const res = fuse.search(e.target.value);
            if(res.length) renderer.focusNode(res[0].item.id);
            else renderer.clearHighlights();
        });
        
        // Filters
        document.querySelectorAll('.filter-btn').forEach(btn => btn.addEventListener('click', () => {
           // ... (filter logic same as before) ...
           const type = btn.dataset.filter;
           const active = btn.classList.contains('active');
           document.querySelectorAll(`[data-filter="${type}"]`).forEach(b=>b.classList.remove('active'));
           if(!active) btn.classList.add('active');
           renderer.applyFilters({
               gender: document.querySelector('[data-filter="gender"].active')?.dataset.value,
               status: document.querySelector('[data-filter="status"].active')?.dataset.value
           });
        }));
        
        document.getElementById('loading').style.display='none';
        renderer.render();
        
        // Expose zoom global
        window.zoomIn = () => renderer.pz.zoomIn();
        window.zoomOut = () => renderer.pz.zoomOut();
        window.zoomReset = () => renderer.pz.reset();

    } catch(e) { console.error(e); document.getElementById('loading').textContent = e.message; }
}

window.closeInfo = () => document.getElementById('info-panel').classList.remove('visible');
init();
    </script>
</body>
</html>
