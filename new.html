<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Family Tree (Vanilla JS)</title>
    
    <!-- CDN Libraries (No D3) -->
    <script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>
    <script src="https://unpkg.com/@panzoom/panzoom@4.5.1/dist/panzoom.min.js"></script>
    
    <style>
        /* Styles remain exactly the same as before */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, system-ui, sans-serif; background: #f5f7fa; overflow: hidden; height: 100vh; display: flex; flex-direction: column; }
        
        #controls { background: white; padding: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); z-index: 100; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
        #search-input { flex: 1; min-width: 200px; padding: 10px 14px; border: 2px solid #e1e8ed; border-radius: 8px; font-size: 14px; }
        .filter-group { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .filter-btn { padding: 8px 16px; border: 2px solid #e1e8ed; background: white; border-radius: 20px; cursor: pointer; min-height: 44px; }
        .filter-btn:hover { background: #e8f5fe; border-color: #1da1f2; }
        .filter-btn.active { background: #1da1f2; color: white; border-color: #1da1f2; }
        .reset-btn { padding: 8px 16px; background: #657786; color: white; border: none; border-radius: 20px; cursor: pointer; min-height: 44px; }
        
        #tree-container { flex: 1; position: relative; overflow: hidden; background: #f5f7fa; }
        #tree-svg { width: 100%; height: 100%; cursor: grab; }
        #tree-svg:active { cursor: grabbing; }

        /* Node Styles */
        .person-node { cursor: pointer; transition: transform 0.2s; }
        .person-node:hover { transform: scale(1.05); }
        .person-card { fill: white; stroke: #e1e8ed; stroke-width: 2; rx: 8; ry: 8; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1)); }
        
        .person-card.male { stroke: #4A90E2; }
        .person-card.female { stroke: #E94B8B; }
        .person-card.highlighted { stroke: #FFD700; stroke-width: 4; filter: drop-shadow(0 4px 12px rgba(255,215,0,0.5)); }
        .person-card.collapsed { opacity: 0.7; }
        
        .person-name { font-size: 14px; font-weight: 600; fill: #14171a; pointer-events: none; }
        .person-dates { font-size: 11px; fill: #657786; pointer-events: none; }
        .person-icon { font-size: 16px; pointer-events: none; }
        
        /* Links */
        .link { fill: none; stroke: #AAB8C2; stroke-width: 2; }
        .spouse-link { stroke: #E94B8B; stroke-width: 2; stroke-dasharray: 5,5; }
        
        /* UI Elements */
        #info-panel { position: absolute; top: 20px; right: 20px; background: white; padding: 16px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); max-width: 300px; display: none; z-index: 50; }
        #info-panel.visible { display: block; }
        .close-info { position: absolute; top: 8px; right: 8px; border: none; background: none; font-size: 20px; cursor: pointer; }
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #657786; text-align: center; }
        
        .zoom-controls { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; gap: 8px; }
        .zoom-btn { width: 44px; height: 44px; background: white; border: 2px solid #e1e8ed; border-radius: 50%; cursor: pointer; font-size: 20px; }
    </style>
</head>
<body>
    <div id="controls">
        <input type="text" id="search-input" placeholder="üîç Search by name..." />
        <div class="filter-group">
            <button class="filter-btn" data-filter="gender" data-value="male">üë® Male</button>
            <button class="filter-btn" data-filter="gender" data-value="female">üë© Female</button>
            <button class="filter-btn" data-filter="status" data-value="alive">üíö Alive</button>
            <button class="filter-btn" data-filter="status" data-value="deceased">üïäÔ∏è Deceased</button>
            <button class="reset-btn" id="reset-filters">Reset</button>
        </div>
    </div>

    <div id="tree-container">
        <div id="loading">Loading...</div>
        <svg id="tree-svg"></svg>
        
        <div id="info-panel">
            <button class="close-info" onclick="closeInfo()">√ó</button>
            <div id="info-content"></div>
        </div>

        <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomIn()">+</button>
            <button class="zoom-btn" onclick="zoomReset()">‚äô</button>
            <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
        </div>
    </div>

    <script>
        // ============================================
        // 1. DATA MANAGEMENT (Pure JS - Unchanged)
        // ============================================
        class FamilyTreeData {
            constructor(jsonData) {
                this.rawData = jsonData;
                this.peopleMap = new Map();
                this.roots = [];
                this.collapsed = new Set();
                this.initialize();
            }

            initialize() {
                this.rawData.people.forEach(person => {
                    this.peopleMap.set(person.id, {
                        ...person,
                        parents: person.parents || [],
                        spouses: person.spouses || [],
                        children: person.children || []
                    });
                });
                this.normalizeRelationships();
                this.detectRoots();
            }

            normalizeRelationships() {
                this.peopleMap.forEach((person, id) => {
                    // Bidirectional Spouses
                    person.spouses.forEach(sId => {
                        const s = this.peopleMap.get(sId);
                        if (s && !s.spouses.includes(id)) s.spouses.push(id);
                    });
                    // Bidirectional Parent-Child
                    person.children.forEach(cId => {
                        const c = this.peopleMap.get(cId);
                        if (c && !c.parents.includes(id)) c.parents.push(id);
                    });
                    person.parents.forEach(pId => {
                        const p = this.peopleMap.get(pId);
                        if (p && !p.children.includes(id)) p.children.push(id);
                    });
                });
            }

            detectRoots() {
                const potentialRoots = [];
                this.peopleMap.forEach((p, id) => {
                    if (p.parents.length === 0) potentialRoots.push(id);
                });

                const processed = new Set();
                const rootGroups = [];

                potentialRoots.forEach(pid => {
                    if (processed.has(pid)) return;
                    const p = this.peopleMap.get(pid);
                    const group = [pid];
                    processed.add(pid);

                    p.spouses.forEach(sid => {
                        const s = this.peopleMap.get(sid);
                        if (!s) return;
                        if (s.parents.length > 0) return; // Spouse has lineage, let them lead
                        if (!processed.has(sid)) {
                            group.push(sid);
                            processed.add(sid);
                        }
                    });
                    if (group.length > 0) rootGroups.push(group);
                });
                
                this.roots = rootGroups.map(g => g[0]);
                if(this.roots.length === 0 && this.peopleMap.size > 0) {
                     // Fallback
                     this.roots = [this.peopleMap.keys().next().value];
                }
            }

            getPerson(id) { return this.peopleMap.get(id); }
            toggleCollapse(id) {
                this.collapsed.has(id) ? this.collapsed.delete(id) : this.collapsed.add(id);
            }
            isCollapsed(id) { return this.collapsed.has(id); }
            
            getAllAncestors(id, visited = new Set()) {
                if (visited.has(id)) return [];
                visited.add(id);
                const person = this.getPerson(id);
                if(!person) return [];
                let res = [];
                person.parents.forEach(pid => {
                    res.push(pid);
                    res = res.concat(this.getAllAncestors(pid, visited));
                });
                return res;
            }

            getAllDescendants(id, visited = new Set()) {
                if (visited.has(id)) return [];
                visited.add(id);
                const person = this.getPerson(id);
                if(!person) return [];
                let res = [];
                person.children.forEach(cid => {
                    res.push(cid);
                    res = res.concat(this.getAllDescendants(cid, visited));
                });
                return res;
            }
        }

        // ============================================
        // 2. LAYOUT ENGINE (Pure JS - Unchanged)
        // ============================================
        class TreeLayout {
            constructor(familyData) {
                this.data = familyData;
                this.nodeW = 180;
                this.nodeH = 80;
                this.gapH = 40;
                this.gapV = 100;
                this.spouseGap = 20;
            }

            buildHierarchy(rootId, depth = 0, visited = new Set()) {
                if (visited.has(rootId)) return null;
                visited.add(rootId);
                const person = this.data.getPerson(rootId);
                if (!person) return null;

                const node = {
                    id: rootId,
                    data: person,
                    depth: depth,
                    children: [],
                    spouses: [],
                    x: 0, y: depth * (this.nodeH + this.gapV)
                };

                person.spouses.forEach(sid => {
                    const s = this.data.getPerson(sid);
                    if (s) node.spouses.push({ id: sid, data: s, x:0, y: node.y });
                });

                if (!this.data.isCollapsed(rootId)) {
                    person.children.forEach(cid => {
                        const childNode = this.buildHierarchy(cid, depth + 1, visited);
                        if (childNode) node.children.push(childNode);
                    });
                }
                return node;
            }

            calculatePositions(node, x = 0) {
                if (!node) return 0;
                let childrenW = 0;
                let childX = x;

                node.children.forEach((child, i) => {
                    const w = this.calculatePositions(child, childX);
                    childX += w + this.gapH;
                    childrenW += w + (i > 0 ? this.gapH : 0);
                });

                const selfW = this.nodeW + (node.spouses.length * (this.nodeW + this.spouseGap));
                const totalW = Math.max(selfW, childrenW);

                if (node.children.length > 0) {
                    const center = x + childrenW / 2;
                    node.x = center - selfW / 2;
                } else {
                    node.x = x;
                }

                node.spouses.forEach((s, i) => {
                    s.x = node.x + (i + 1) * (this.nodeW + this.spouseGap);
                });

                return totalW;
            }

            layoutMultipleRoots(roots) {
                const trees = [];
                let offX = 0;
                roots.forEach(rid => {
                    const tree = this.buildHierarchy(rid);
                    if (tree) {
                        this.calculatePositions(tree, 0); // Calculate internal relative positions
                        this.shiftTree(tree, offX); // Shift absolute position
                        trees.push(tree);
                        offX += this.getTreeWidth(tree) + this.gapH * 2;
                    }
                });
                return trees;
            }

            shiftTree(node, dx) {
                node.x += dx;
                node.spouses.forEach(s => s.x += dx);
                node.children.forEach(c => this.shiftTree(c, dx));
            }

            getTreeWidth(node) {
                // Simple bounds check
                let maxX = node.x + this.nodeW;
                node.spouses.forEach(s => maxX = Math.max(maxX, s.x + this.nodeW));
                node.children.forEach(c => maxX = Math.max(maxX, this.getTreeWidth(c)));
                return maxX; // Relative to 0 start, approximate for spacing
            }
        }

        // ============================================
        // 3. RENDERER (REWRITTEN: Vanilla JS SVG)
        // ============================================
        class TreeRenderer {
            constructor(svgElement, familyData) {
                this.svg = svgElement;
                this.data = familyData;
                this.layout = new TreeLayout(familyData);
                this.ns = "http://www.w3.org/2000/svg"; // XML Namespace
                
                this.highlighted = new Set();
                this.filters = { gender: null, status: null };

                // Create Groups Structure
                this.mainGroup = document.createElementNS(this.ns, 'g');
                this.linkGroup = document.createElementNS(this.ns, 'g');
                this.nodeGroup = document.createElementNS(this.ns, 'g');
                
                this.mainGroup.appendChild(this.linkGroup);
                this.mainGroup.appendChild(this.nodeGroup);
                this.svg.appendChild(this.mainGroup);

                this.setupPanZoom();
            }

            setupPanZoom() {
                this.pz = Panzoom(this.mainGroup, {
                    maxScale: 3, minScale: 0.1, contain: 'outside'
                });
                this.svg.addEventListener('wheel', (e) => {
                    if (!e.shiftKey) this.pz.zoomWithWheel(e);
                });
                // Expose to global
                window.zoomIn = () => this.pz.zoomIn();
                window.zoomOut = () => this.pz.zoomOut();
                window.zoomReset = () => this.pz.reset();
            }

            render() {
                // 1. Calculate Layout
                const trees = this.layout.layoutMultipleRoots(this.data.roots);
                
                // 2. Clear previous render
                this.linkGroup.innerHTML = '';
                this.nodeGroup.innerHTML = '';

                // 3. Flatten tree to list of nodes/links
                const renderList = { nodes: [], links: [] };
                trees.forEach(tree => this.traverse(tree, renderList));

                // 4. Draw
                this.drawLinks(renderList.links);
                this.drawNodes(renderList.nodes);
                
                // 5. Center View (only on first load usually, but here every render for simplicity)
                // Note: In a real app, check if it's the first render before centering
                if (!this.hasCentered) {
                    setTimeout(() => this.centerView(), 100); 
                    this.hasCentered = true;
                }
            }

            traverse(node, list) {
                if (this.isFiltered(node.data)) {
                    list.nodes.push(node);
                    
                    // Spouses
                    node.spouses.forEach(s => {
                        if (this.isFiltered(s.data)) {
                            list.nodes.push(s);
                            list.links.push({ type: 'spouse', source: node, target: s });
                        }
                    });

                    // Children
                    node.children.forEach(child => {
                        list.links.push({ type: 'child', source: node, target: child });
                        this.traverse(child, list);
                    });
                }
            }

            isFiltered(p) {
                if (this.filters.gender && p.gender !== this.filters.gender) return false;
                if (this.filters.status === 'alive' && p.deathDate) return false;
                if (this.filters.status === 'deceased' && !p.deathDate) return false;
                return true;
            }

            drawLinks(links) {
                const frag = document.createDocumentFragment();
                const nodeW = this.layout.nodeW;
                const nodeH = this.layout.nodeH;

                links.forEach(l => {
                    if (l.type === 'spouse') {
                        const line = document.createElementNS(this.ns, 'line');
                        this.setAttrs(line, {
                            x1: l.source.x + nodeW, y1: l.source.y + nodeH/2,
                            x2: l.target.x, y2: l.target.y + nodeH/2,
                            class: 'spouse-link'
                        });
                        frag.appendChild(line);
                    } else {
                        const sx = l.source.x + nodeW/2;
                        const sy = l.source.y + nodeH;
                        const tx = l.target.x + nodeW/2;
                        const ty = l.target.y;
                        
                        const path = document.createElementNS(this.ns, 'path');
                        const d = `M ${sx},${sy} V ${sy + this.layout.gapV/2} H ${tx} V ${ty}`;
                        this.setAttrs(path, { d: d, class: 'link' });
                        frag.appendChild(path);
                    }
                });
                this.linkGroup.appendChild(frag);
            }

            drawNodes(nodes) {
                const frag = document.createDocumentFragment();
                
                nodes.forEach(n => {
                    const g = document.createElementNS(this.ns, 'g');
                    this.setAttrs(g, {
                        class: 'person-node',
                        transform: `translate(${n.x}, ${n.y})`,
                        'data-id': n.id
                    });
                    
                    // Click Handler
                    g.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent panzoom trigger
                        this.handleNodeClick(n);
                    });

                    // Styling logic
                    let cardClass = `person-card ${n.data.gender}`;
                    if (this.highlighted.has(n.id)) cardClass += ' highlighted';
                    if (this.data.isCollapsed(n.id)) cardClass += ' collapsed';

                    // Rect
                    const rect = document.createElementNS(this.ns, 'rect');
                    this.setAttrs(rect, {
                        width: this.layout.nodeW, height: this.layout.nodeH,
                        class: cardClass
                    });
                    g.appendChild(rect);

                    // Name
                    const name = document.createElementNS(this.ns, 'text');
                    name.textContent = n.data.name;
                    this.setAttrs(name, { x: 35, y: 25, class: 'person-name' });
                    g.appendChild(name);

                    // Icon
                    const icon = document.createElementNS(this.ns, 'text');
                    icon.textContent = n.data.gender === 'male' ? 'üë®' : (n.data.gender === 'female' ? 'üë©' : 'üë§');
                    this.setAttrs(icon, { x: 10, y: 25, class: 'person-icon' });
                    g.appendChild(icon);

                    // Dates
                    const dates = document.createElementNS(this.ns, 'text');
                    dates.textContent = `${n.data.birthDate || '?'} - ${n.data.deathDate || ''}`;
                    this.setAttrs(dates, { x: 10, y: 45, class: 'person-dates' });
                    g.appendChild(dates);

                    // Collapse Button
                    if (n.data.children && n.data.children.length > 0) {
                        const btnG = document.createElementNS(this.ns, 'g');
                        this.setAttrs(btnG, {
                            class: 'collapse-indicator',
                            transform: `translate(${this.layout.nodeW - 25}, ${this.layout.nodeH - 25})`
                        });
                        
                        const circle = document.createElementNS(this.ns, 'circle');
                        this.setAttrs(circle, { r: 10, cx: 0, cy: 0 });
                        
                        const sym = document.createElementNS(this.ns, 'text');
                        sym.textContent = this.data.isCollapsed(n.id) ? '+' : '‚àí';
                        this.setAttrs(sym, {
                            fill: 'white', 'text-anchor': 'middle', 'dominant-baseline': 'central',
                            'pointer-events': 'none', 'font-size': '12px'
                        });

                        btnG.appendChild(circle);
                        btnG.appendChild(sym);
                        
                        btnG.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.data.toggleCollapse(n.id);
                            this.render();
                        });
                        g.appendChild(btnG);
                    }

                    frag.appendChild(g);
                });
                this.nodeGroup.appendChild(frag);
            }

            // Helper for setting attributes
            setAttrs(el, attrs) {
                for (const [key, val] of Object.entries(attrs)) {
                    el.setAttribute(key, val);
                }
            }

            handleNodeClick(node) {
                this.highlighted.clear();
                this.highlighted.add(node.id);
                this.data.getAllAncestors(node.id).forEach(id => this.highlighted.add(id));
                this.data.getAllDescendants(node.id).forEach(id => this.highlighted.add(id));
                node.data.spouses.forEach(id => this.highlighted.add(id));
                
                this.render();
                this.showInfo(node.data);
            }

            showInfo(data) {
                const p = document.getElementById('info-panel');
                const c = document.getElementById('info-content');
                c.innerHTML = `<h3>${data.name}</h3>
                               <p>${data.gender} | ${data.birthDate || '?'} - ${data.deathDate || 'Present'}</p>
                               <p>${data.notes || ''}</p>`;
                p.classList.add('visible');
            }

            centerView() {
                const bbox = this.mainGroup.getBBox();
                const parent = this.svg.getBoundingClientRect();
                if (bbox.width === 0) return;

                const scale = Math.min(parent.width / (bbox.width + 100), parent.height / (bbox.height + 100), 1);
                const x = (parent.width - bbox.width * scale) / 2 - bbox.x * scale;
                const y = 50;

                this.pz.pan(x, y);
                this.pz.zoom(scale);
            }

            applyFilters(f) {
                this.filters = f;
                this.render();
            }

            focusNode(id) {
                // Expand ancestors
                this.data.getAllAncestors(id).forEach(aid => {
                   if(this.data.isCollapsed(aid)) this.data.toggleCollapse(aid); 
                });
                this.highlighted.clear();
                this.highlighted.add(id);
                this.render();

                // Find coords and pan
                const person = this.data.getPerson(id);
                // Need to find node in current render list to get X/Y. 
                // Since render() was just called, layout is fresh. 
                // Ideally we'd map ID->Coords during render. simpler:
                setTimeout(() => {
                    const el = this.nodeGroup.querySelector(`[data-id="${id}"]`);
                    if(el) {
                        // Extract transform
                        const transform = el.getAttribute('transform');
                        const [_, x, y] = transform.match(/translate\(([\d.-]+),\s*([\d.-]+)\)/).map(Number);
                        const parent = this.svg.getBoundingClientRect();
                        const scale = this.pz.getScale();
                        
                        // Center logic is complex with Panzoom, simplified:
                        const cx = (parent.width / 2) - (x * scale) - (this.layout.nodeW/2 * scale);
                        const cy = (parent.height / 2) - (y * scale) - (this.layout.nodeH/2 * scale);
                        this.pz.pan(cx, cy);
                    }
                }, 50);
            }
            
            clearHighlights() { this.highlighted.clear(); this.render(); }
        }

        // ============================================
        // 4. APP INITIALIZATION
        // ============================================
        async function init() {
            try {
                const response = await fetch('./family-tree.json');
                if(!response.ok) throw new Error("Could not load data");
                const jsonData = await response.json();
                
                const data = new FamilyTreeData(jsonData);
                const renderer = new TreeRenderer(document.getElementById('tree-svg'), data);
                
                // Search Setup
                const fuse = new Fuse(jsonData.people, { keys: ['name'], threshold: 0.3 });
                document.getElementById('search-input').addEventListener('input', (e) => {
                   const res = fuse.search(e.target.value);
                   if(res.length) renderer.focusNode(res[0].item.id);
                   else renderer.clearHighlights();
                });

                // Filter Setup
                document.querySelectorAll('.filter-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const type = btn.dataset.filter;
                        const val = btn.dataset.value;
                        const active = btn.classList.contains('active');
                        
                        document.querySelectorAll(`[data-filter="${type}"]`).forEach(b=>b.classList.remove('active'));
                        
                        if(!active) btn.classList.add('active');
                        
                        const filters = {
                            gender: document.querySelector('[data-filter="gender"].active')?.dataset.value,
                            status: document.querySelector('[data-filter="status"].active')?.dataset.value
                        };
                        renderer.applyFilters(filters);
                    });
                });
                
                document.getElementById('reset-filters').addEventListener('click', () => {
                   document.querySelectorAll('.filter-btn').forEach(b=>b.classList.remove('active'));
                   renderer.applyFilters({});
                });

                document.getElementById('loading').style.display = 'none';
                renderer.render();

            } catch (e) {
                document.getElementById('loading').innerHTML = `Error: ${e.message}<br>Use a local server!`;
            }
        }

        window.closeInfo = () => document.getElementById('info-panel').classList.remove('visible');
        init();
    </script>
</body>
</html>
